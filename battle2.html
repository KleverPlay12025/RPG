<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battle Menu</title>
  <style>
    body {
        
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #222;
      flex-direction: column;
      gap: 50px;
      margin: 0;
      overflow: hidden;
      color: white;
    }

    #background {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: url('./Imagenes/fondo2.png');
      background-size: cover;
      background-position: center;
      z-index: -1;
    }

    .character {
      position: relative;
    }

    .character-container {
      display: flex;
      gap: 20px;
      padding-left: 20px;
    }

    .character:hover img {
      transform: scale(1.1) rotateY(15deg) rotateX(5deg); /* Efecto 3D de rotación */
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); /* Sombra para dar profundidad */
    }

    .character:hover {
      transform: translateY(-10px) rotate(5deg); /* Efecto de elevación con rotación */
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
    }

    .character img {
      
      width: 150px;
      height: 150px;
      object-fit: cover;
      border-radius: 10px;
      border: 3px solid transparent;
      transition: transform 0.3s ease, box-shadow 0.3s ease, filter 0.3s ease;
    }

    .character.selected img {
      border: 3px solid yellow;
    }

    .finalizarTurno {
      background: linear-gradient(135deg, #390ba5, #6a3bd8);
    }

    .character-info {
      background: rgba(0, 0, 0, 0.7);
      padding: 5px;
      border-radius: 5px;
      margin-top: 5px;
      text-align: center;
    }

    .enemy-container {
      position: relative;
      text-align: center;
      margin-top: 20px;
    }

    .enemy-container img {
      width: 180px;
      height: 180px;
      border-radius: 10px;
    }

    .menu {
  position: absolute;
  left: 20px;
  bottom: 20px;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 15px;
  background: rgba(0, 0, 0, 0.85);
  padding: 25px 30px;
  border-radius: 15px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
  border: 2px solid rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  perspective: 800px;
  transform-style: preserve-3d;
  transform: rotateX(10deg) translateZ(0);
  transition: transform 0.5s ease, opacity 0.5s ease;
  opacity: 0.95;
  animation: menuEntry 1s ease-out;
}

@keyframes menuEntry {
  0% {
    opacity: 0;
    transform: rotateX(15deg) translateZ(-50px);
  }
  60% {
    opacity: 1;
    transform: rotateX(-5deg) translateZ(10px);
  }
  100% {
    transform: rotateX(0deg) translateZ(0);
  }
}

.menu:hover {
  transform: rotateX(0deg) translateZ(20px) scale(1.05);
  opacity: 1;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
}

.menu button {
  color: white;
  font-size: 18px;
  font-weight: 600;
  text-transform: uppercase;
  padding: 10px 20px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  transition: background-color 0.3s ease, transform 0.3s ease, text-shadow 0.3s ease;
  transform: perspective(800px) rotateX(5deg);
}

.menu button:hover {
  background-color: rgba(255, 255, 255, 0.2);
  transform: perspective(800px) rotateX(0deg) translateY(-3px);
  box-shadow: 0 4px 10px rgba(255, 255, 255, 0.5);
}

    .damage-number {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      font-size: 30px;
      font-weight: bold;
      text-shadow: 1px 1px 2px black;
      opacity: 1;
      transition: opacity 1s ease-out, transform 1s ease-out;
    }

    @keyframes floatDamage {
      0% {
        opacity: 1;
        transform: translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateY(-50px);
      }
    }

    .damage-negative {
      color: #ff4444;
    }

    .damage-magic {
      color: #9b11c5;
    }

    .damage-positive {
      color: #44ff44;
    }

    .damage-defend {
      color: #44e3ff;
    }

    .damage-critical {
      color: #ffaa2b;
    }
    .damage-veneno {
      color: #2bff36;
      transform: translateY(-80px); /* Mueve el texto 10px hacia arriba */
    } 
    .damage-global {
      color: #020000;
    }

    @keyframes healAnimation {
      0% {
        transform: perspective(500px) scale(1) rotateX(0deg) rotateY(0deg);
        opacity: 1;
      }
      20% {
        transform: perspective(500px) scale(1.3) rotateX(15deg) rotateY(10deg);
        opacity: 0.9;
      }
      40% {
        transform: perspective(500px) scale(1.5) rotateX(-15deg) rotateY(-10deg);
        opacity: 0.8;
      }
      60% {
        transform: perspective(500px) scale(1.3) rotateX(10deg) rotateY(15deg);
        opacity: 0.9;
      }
      80% {
        transform: perspective(500px) scale(1.4) rotateX(-5deg) rotateY(5deg);
        opacity: 0.95;
      }
      100% {
        transform: perspective(500px) scale(1) rotateX(0deg) rotateY(0deg);
        opacity: 1;
      }
    }

    .healing-animation {
      animation: healAnimation 1s ease-in-out;
    }

    @keyframes underlineEffect {
      0% {
        transform: scaleX(0);
        transform-origin: bottom left;
      }
      100% {
        transform: scaleX(1);
        transform-origin: bottom right;
      }
    }

    .menu a:hover,
    .menu button:hover {
      transform: translateY(-5px) scale(1.05) rotateX(30deg);
    }

    .menu button {
      width: 180px;
      padding: 12px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #ff4b2b, #ff416c);
      color: white;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6);
    }

    .menu button:hover {
      background: linear-gradient(135deg, #ff6a00, #ee0979);
      transform: scale(1.1);
      box-shadow: 0 4px 10px rgba(255, 65, 108, 0.7);
    }

    .health {
      width: 180px;
      padding: 12px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #c2ff4f, #ff416c);
      color: white;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }

    .health::first-letter {
      font-size: 1.5em;
      font-weight: bold;
    }

    .attack-effect {
      animation: attackAnimation 0.3s ease-in-out;
    }

    @keyframes enemyAttack {
      0% { transform: rotateZ(0deg) scaleX(1); }
      25% { transform: rotateZ(30deg) scaleX(1.5); }
      50% { transform: rotateZ(-30deg) scaleX(1); }
      75% { transform: rotateZ(20deg) scaleX(1.4); }
      100% { transform: rotateZ(0deg) scaleX(1); }
    }

    @keyframes attackAnimation {
      0% { transform: scale(1) translateY(0); }
      50% { transform: scale(1.5) translateY(80px); }
      100% { transform: scale(1) translateY(0); }
    }

    @keyframes hurtAnimation {
      0% { transform: translateX(0) scale(1); }
      50% { transform: translateX(-40px) translateY(-40px) scale(0.8); }
      100% { transform: translateX(0) translateY(0) scale(1); }
    }

    @keyframes defendAnimation {
      0% { transform: rotateY(0deg) scale(1); }
      50% { transform: rotateY(360deg) scale(1.2); }
      100% { transform: rotateY(0deg) scale(1); }
    }

    .defending {
      animation: defendAnimation 0.7s ease-out;
    }

    .hurt {
      animation: hurtAnimation 0.2s ease-in-out;
    }

    .enemy-attack {
      animation: enemyAttack 0.5s ease-in-out;
    }

    #heal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .heal-target {
    margin: 10px;
    border: 3px solid transparent;
    border-radius: 10px;
    transition: border 0.3s ease;
  }
  .heal-target:hover {
    border: 3px solid green;
    cursor: pointer;
  }

  .health-bar {
  position: relative;
  width: 150px;
  height: 5px;
  background: linear-gradient(45deg, #ff4d4d, #ff1a1a); /* Gradiente para fondo */
  border-radius: 5px;
  box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5); /* Sombra interna para dar profundidad */
  overflow: hidden;
  margin-top: 5px;
}

.health-fill {
  height: 100%;
  width: 100%; /* Se actualizará dinámicamente desde JS */
  background: linear-gradient(45deg, #00ff00, #c1ffc1); /* Gradiente verde para la salud */
  border-radius: 5px;
  transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* Transición suave y dinámica */
}

/* Contenedor para la animación de selección */
#selected-character-display {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none; /* Para que no interfiera con clicks */
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding-top: 50px; /* Para que el nombre quede más arriba */
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.5s ease, transform 0.5s ease;
  z-index: 2000;
}

/* Clase activa para mostrar la animación */
#selected-character-display.active {
  opacity: 1;
  transform: translateY(0);
}

/* Nombre del personaje en grande a la izquierda */

#selected-character-display .selected-name {
  font-size: 4em;
  font-weight: bold;
  margin-left: 50px;
  color: #fff;
  text-shadow: 2px 2px 5px rgba(0,0,0,0.7);
  animation: slideInLeft 0.5s ease forwards;
}
/* Imagen del personaje a la derecha con 50% de opacidad y mayor tamaño */
#selected-character-display .selected-image {
  width: 1200px;
  height: 1200px;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  opacity: 0.5;
  margin-left: 600px;
  animation: slideInRight 0.5s ease forwards;
}

/* Animación para el nombre (deslizar desde la izquierda) */
@keyframes slideInLeft {
  0% {
    opacity: 0;
    transform: translateX(-50px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Animación para la imagen (deslizar desde la derecha) */
@keyframes slideInRight {
  0% {
    opacity: 0;
    transform: translateX(50px);
  }
  100% {
    opacity: 0.7;
    transform: translateX(0);
  }
}

/* Animaciones para ocultar (fade out y desplazamiento) */
@keyframes fadeOutLeft {
  0% {
    opacity: 1;
    transform: translateX(0);
  }
  100% {
    opacity: 0;
    transform: translateX(-50px);
  }
}

@keyframes fadeOutRight {
  0% {
    opacity: 0.5;
    transform: translateX(0);
  }
  100% {
    opacity: 0;
    transform: translateX(50px);
  }
}

#damage-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1000;
    background: linear-gradient(to top, rgba(255, 0, 0, var(--overlay-opacity)) 20%, rgba(255, 0, 0, calc(var(--overlay-opacity) * 0.5)) 50%, rgba(255, 0, 0, 0) 80%);
    transition: background 0.3s ease-in-out;
}
@keyframes darkenAnimation {
  0% {
    filter: brightness(1);
  }
  100% {
    filter: brightness(0.2);
  }
}
#background.darken {
  filter: brightness(0.2);
  transition: filter 0.5s ease-out;
}

@keyframes shake {
  0% { transform: translate(0, 0); }
  20% { transform: translate(-10px, 10px); }
  40% { transform: translate(10px, -10px); }
  60% { transform: translate(-10px, 10px); }
  80% { transform: translate(10px, -10px); }
  100% { transform: translate(0, 0); }
}

.shake {
  animation: shake 0.5s linear;
}

@keyframes flash {
  0% {
    opacity: 0;
    filter: brightness(1);
  }
  40% {
    opacity: 1;
    filter: brightness(5);
  }
  100% {
    opacity: 1;
    filter: brightness(1);
  }
}

.flash {
  animation: flash 0.5s ease-out, shake 0.5s linear;
}

/* Estilos específicos para los botones de la habilidad de Darina */
.skill-button {
  font-size: 20px;
  padding: 12px 25px;
  background: linear-gradient(45deg, #800080, #000000); /* De morado (#800080) a negro */
  border-radius: 10px;
  color: #ff61ff; /* Texto en un morado claro */
  transition: background 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease, color 0.3s ease;
}

.skill-button:hover {
  transform: translateY(-3px);
  box-shadow: 0 0 15px 5px #640932; /* Brillo fuerte en rosa */
}

/* Estilos separados para cada botón, si es necesario */
.left-btn {
  margin-right: 20px;
}

.right-btn {
  margin-left: 20px;
}

/* Opcional: estilos para la imagen central */
.skill-center-image {
  width: 500px;
  height: auto;
  margin: 0 20px;
}
  </style>
</head>
<body>
  <div id="background"></div>
  <audio id="attackSound" src="./Sonidos/atacar.mp3"></audio>
  <audio id="attackSound2" src="./Sonidos/atacarCRIT.mp3"></audio>
  <audio id="defendSound" src="./Sonidos/escudo.mp3"></audio>
  <audio id="healSound" src="./Sonidos/curarse.mp3"></audio>
  <audio id="magicSound" src="./Sonidos/magia.mp3"></audio>
  <audio id="EnemyAttack" src="./Sonidos/EnemyAttack.mp3"></audio>
  <audio id="bgAudio" src="./Sonidos/MournwealdEncounter.mp3" loop></audio>
  <audio id="veneno" src="./Sonidos/veneno.mp3"></audio>
  <audio id="global" src="./Sonidos/global.mp3"></audio>


  <div class="character-container">
    <div class="character" id="hero1" onclick="selectCharacter('Heroe')">
      <img src="./Imagenes/Heroe.png" alt="Heroe">
      <div class="character-info">✞ Heroe</div>
      <!-- Barra de vida -->
  <div class="health-bar">
    <div class="health-fill"></div>
  </div>
    </div>
    <div class="character" id="hero2" onclick="selectCharacter('Magiño')">
      <img src="./Imagenes/Magiño.png" alt="Magiño">
      <div class="character-info">۞ Magiño</div>
      <!-- Barra de vida -->
  <div class="health-bar">
    <div class="health-fill"></div>
  </div>
    </div>
    <div class="character" id="hero3" onclick="selectCharacter('Darina')">
      <img src="./Imagenes/Darina.png" alt="Darina">
      <div class="character-info">⁂ Darina</div>
      <!-- Barra de vida -->
  <div class="health-bar">
    <div class="health-fill"></div>
  </div>
    </div>
    <div class="character" id="hero4" onclick="selectCharacter('Geralt')">
      <img src="./Imagenes/Geralt.png" alt="Geralt">
      <div class="character-info">⛨ Geralt</div>
      <!-- Barra de vida -->
  <div class="health-bar">
    <div class="health-fill"></div>
  </div>
    </div>
  </div>

  <div id="enemy" class="enemy-container">
    <img src="./Imagenes/boss2.png" alt="Mournweald">
    <div class="character-info" id="enemy-health">Mournweald - HP: 800</div>
  </div>

  <div class="menu">
    <div class="health" id="player-health">Vida: 120</div>
    <div class="health" id="player-mana">Mana: 50</div>
    <div class="health" id="player-items">Curar: 3</div>
    <button onclick="attack()">Atacar</button>
    <button onclick="defend()">Defender</button>
    <button onclick="useItem()">Curar</button>
    <button onclick="castMagic()">Magia</button>
    <button onclick="endTurn()">Finalizar Turno</button>
  </div>
  <div id="selected-character-display">
    <div class="selected-name"></div>
    <div class="selected-image"></div>
  </div>
  <div id="damage-overlay" style="position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:1000;"></div>
  <script>
    // Inicio de audio de fondo tras el primer clic
    function startAudio() {
      const audio = document.getElementById("bgAudio");
      audio.play();
      document.removeEventListener("click", startAudio);
    }
    document.addEventListener("click", startAudio);

    class Character {
    constructor(name, hp, attack, defense, mana = 0, imgAlive, imgDead, items = 3) {
        this.name = name;
        this.maxHp = hp;
        this.hp = hp;
        this.attack = attack;
        this.defense = defense;
        this.mana = mana;
        this.items = items;
        this.defending = false;
        this.finturno = false;
        this.imgAlive = imgAlive;
        this.imgDead = imgDead;
    }
      

      takeDamage(damage) {
        if (this.hp <= 0) return;
        let finalDamage = Math.max(damage - this.defense, 1);
        if (this.defending) {
          finalDamage = Math.floor(finalDamage / 2);
          this.defending = false;
        }
        this.hp = Math.max(this.hp - finalDamage, 0);
        updateStats();
      }

      attackEnemy(enemy) {
        if (this.hp <= 0) return;
        enemy.takeDamage(this.attack);
        updateStats();
      }

      defend() {
        if (this.hp <= 0) return;
        this.defending = true;
        updateStats();
      }

      useItem() {
  // Si el personaje está muerto o no tiene ítems, no puede curar
  if (this.hp <= 0 || this.items <= 0) return;

  // Si es el héroe, permite seleccionar a quién curar y finaliza la función
  if (selectedCharacter.name === "Heroe") {
    if (this.hp <= 0 || this.items <= 0) return;
    selectHealTarget();
    selectedCharacter.finturno = true;
    return; // Evita que se ejecute la curación sobre el héroe si no es lo deseado
  }

  // Para los otros personajes, procede a curar directamente
  const healAmount = Math.floor(this.maxHp * 0.5);
  this.hp = Math.min(this.hp + healAmount, this.maxHp);
  this.items--;
  updateStats();
}

      useMagic(enemy) {
        if (this.hp <= 0 || this.mana < 10) return;
        const magicDamage = Math.floor(this.attack * 4);
        this.mana -= 10;
        enemy.takeDamage(magicDamage);
        // Cambio temporal del sprite para Darina y Magiño
        if (this.name === "Darina") {
          this.sprite = "./Imagenes/DarinaMag.png";
        } else if (this.name === "Magiño") {
          this.sprite = "./Imagenes/MagiñoMag.png";
        }
        updateStats();
        setTimeout(() => {
          if (this.name === "Darina") {
            this.sprite = "Darina.png";
          } else if (this.name === "Magiño") {
            this.sprite = "Magiño.png";
          }
        }, 500);
      }
    }

    const characters = {
        "Heroe": new Character("Heroe", 100, 24, 0, 0, "./Imagenes/Heroe.png", "./Imagenes/HeroeMuerto.png", 10),
      "Magiño": new Character("Magiño", 90, 13, 0, 100, "./Imagenes/Magiño.png", "./Imagenes/MagiñoMuerto.png", 2),
      "Darina": new Character("Darina", 100, 16, 0, 30, "./Imagenes/Darina.png", "./Imagenes/DarinaMuerta.png", 2),
      "Geralt": new Character("Geralt", 130, 26, 0, 0, "./Imagenes/Geralt.png", "./Imagenes/GeraltMuerto.png", 2)
    };
    let enemy = new Character("Mournweald", 800, 16, 6, 0, "./Imagenes/boss2.png", "./Imagenes/boss2Muerto.png");
    let selectedCharacter = characters["Heroe"];

    function selectCharacter(characterName) {
      const character = characters[characterName];
      if (character.finturno) return; // Si ya terminó el turno no se cambia la selección
      selectedCharacter = character;

      // Reiniciar borde de todos y marcar el seleccionado
      document.querySelectorAll('.character img').forEach(img => {
        img.style.border = "3px solid transparent";
      });
      const index = Object.keys(characters).indexOf(characterName) + 1;
      document.querySelector(`#hero${index} img`).style.border = "3px solid yellow";
      showSelectedCharacterEffect(character);
      updateStats();
    }

    function selectHealTarget() {
  const overlay = document.createElement('div');
  overlay.id = 'heal-overlay';

  // Se muestran todos los personajes vivos como opciones
  Object.keys(characters).forEach(charName => {
    const char = characters[charName];
    if (char.hp > 0) {
      const img = document.createElement('img');
      img.src = char.imgAlive;
      img.alt = char.name;
      img.classList.add('heal-target');
      img.style.width = '150px';
      img.style.height = '150px';
      img.addEventListener('click', () => {
        applyHeal(char);
        document.body.removeChild(overlay);
      });
      overlay.appendChild(img);
    }
  });

  document.body.appendChild(overlay);
}

let yaCurao = false;
function applyHeal(target) {
  const healAmount = Math.floor(target.maxHp * 0.5);
  target.hp = Math.min(target.hp + healAmount, target.maxHp);

  // Si el héroe usa el item, se descuentan de él; en caso contrario, se descuenta del propio personaje
  if (selectedCharacter.name === "Heroe") {
    characters["Heroe"].items--;
  } else {
    target.items--;
  }

  const healSound = document.getElementById("healSound");
  healSound.currentTime = 0;
  healSound.play();
  yaCurao = true;

  const index = Object.keys(characters).indexOf(target.name) + 1;
  const charElement = document.querySelector(`#hero${index} img`); // Mover esto arriba
  triggerEffect(".character", healAmount, "heal");

  // Cambiar imagen de curación no funciona x,d
  switch (selectedCharacter.name) {
    case "Darina":
      charElement.src = "./Imagenes/DarinaCu.png";
      break;
    case "Magiño":
      charElement.src = "./Imagenes/MagiñoCu.png";
      break;
    case "Heroe":
      charElement.src = "./Imagenes/HeroeCu.png";
      break;
    case "Geralt":
      charElement.src = "./Imagenes/GeraltCu.png";
      break;
  }

  updateStats();
  charElement.classList.add("healing-animation");

  setTimeout(() => {
    charElement.classList.remove("healing-animation");
    updateStats();
  }, 5000);
}

    function updateStats() {
        updatePartyDamageEffect();
      document.getElementById("player-health").innerText = `Vida: ${selectedCharacter.hp}`;
      document.getElementById("player-mana").innerText = `Mana: ${selectedCharacter.mana}`;
      document.getElementById("player-items").innerText = `Vendajes: ${selectedCharacter.items}`;
      document.getElementById("enemy-health").innerText = `Mournweald - HP: ${enemy.hp}`;

      Object.keys(characters).forEach((charName, index) => {
        const char = characters[charName];
        const charElement = document.querySelector(`#hero${index + 1} img`);
        if (char.hp <= 0) {
          charElement.src = char.imgDead;
        } else if (char.defending) {
          charElement.src = `./Imagenes/${char.name}Def.png`;
        } else {
          charElement.src = char.imgAlive;
        }
        if (char.finturno) {
          charElement.style.border = "3px solid red";
        }
      });

      Object.keys(characters).forEach((charName, index) => {
  const char = characters[charName];
  const healthFill = document.querySelector(`#hero${index + 1} .health-fill`);
  if (healthFill) {
    // Calcula el porcentaje de vida
    const percentage = (char.hp / char.maxHp) * 100;
    healthFill.style.width = percentage + '%';
  }
});

      // Actualizar imagen del enemigo solo si no está atacando
      const enemyElement = document.querySelector(".enemy-container img");
      if (enemy.hp <= 0) {
        enemyElement.src = enemy.imgDead;
        setTimeout(() => window.location.href = "YouWin2.html", 1000);
      } else if (!enemyIsAttacking) {
        enemyElement.src = enemy.imgAlive;
      }
    }

    // Inicialización de la imagen del enemigo
    const enemyElement = document.querySelector(".enemy-container img");
    enemyElement.src = enemy.hp <= 0 ? enemy.imgDead : enemy.imgAlive;

    let enemyIsAttacking = false;

    function showSelectedCharacterEffect(character) {
  const display = document.getElementById('selected-character-display');
  const imageDiv = display.querySelector('.selected-image');
  const nameDiv = display.querySelector('.selected-name');

  // Si ya está activo, se aplica la animación de ocultar antes de actualizar
  if (display.classList.contains('active')) {
    nameDiv.style.animation = "fadeOutLeft 0.5s ease forwards";
    imageDiv.style.animation = "fadeOutRight 0.5s ease forwards";
    setTimeout(() => {
      // Actualiza contenido tras ocultarse el anterior
      nameDiv.innerText = character.name;
      imageDiv.style.backgroundImage = `url(${character.imgAlive})`;
      // Reinicia animación de entrada
      nameDiv.style.animation = "slideInLeft 0.5s ease forwards";
      imageDiv.style.animation = "slideInRight 0.5s ease forwards";
    }, 500);
  } else {
    // Primera vez: simplemente establece el contenido y muestra el contenedor
    nameDiv.innerText = character.name;
    imageDiv.style.backgroundImage = `url(${character.imgAlive})`;
    display.classList.add('active');
    nameDiv.style.animation = "slideInLeft 0.5s ease forwards";
    imageDiv.style.animation = "slideInRight 0.5s ease forwards";
  }

  // Remueve la animación después de 3 segundos (o el tiempo que desees)
  clearTimeout(window.hideEffectTimeout);
  window.hideEffectTimeout = setTimeout(() => {
    display.classList.remove('active');
  }, 3000);
}

function attack() {
    if (selectedCharacter.hp <= 0 || enemy.hp <= 0 || selectedCharacter.finturno) return;
    triggerShake(enemyElement);

    const attackSoundNormal = document.getElementById("attackSoundNormal");
    const attackSoundCritical = document.getElementById("attackSoundCritical");

    const index = Object.keys(characters).indexOf(selectedCharacter.name) + 1;
    const heroElement = document.querySelector(`#hero${index} img`);
    heroElement.classList.add("attack-effect");
    setTimeout(() => heroElement.classList.remove("attack-effect"), 300);

    const baseDamage = Math.max(selectedCharacter.attack - enemy.defense, 1);
    const bonus = Math.floor(Math.random() * 9) - 4; // -4 a +4
    const isCritical = Math.random() < 0.2;
    let finalDamage = baseDamage + bonus + (isCritical ? 8 : 0);
    finalDamage = Math.max(finalDamage, 1);

    // **Reproducir sonido adecuado**
    if (isCritical) {
        attackSound2.currentTime = 0;
        attackSound2.play();
    } else {
        attackSound.currentTime = 0;
        attackSound.play();
    }

    enemy.takeDamage(finalDamage);
    selectedCharacter.finturno = true;
    updateStats();

    triggerEffect(".enemy-container", finalDamage, isCritical ? "critical" : "damage");
}

    function defend() {
  const defendSound = document.getElementById("defendSound");
  defendSound.currentTime = 0;
  defendSound.play();
  if (selectedCharacter.hp <= 0 || selectedCharacter.finturno) return;

  // Si Geralt es el seleccionado, todos se defienden.
  if (selectedCharacter.name === "Geralt") {
    Object.keys(characters).forEach(charName => {
      let char = characters[charName];
      // Opcional: evitar aplicar si el personaje ya ha finalizado su turno o está muerto
      if (char.hp <= 0 || char.finturno) return;
      char.defend();
      selectedCharacter.finturno = true;
      selectedCharacter.defend();
      const index = Object.keys(characters).indexOf(charName) + 1;
      const charElement = document.querySelector(`#hero${index} img`);
      charElement.classList.add("defending");

      // Actualizar la imagen de defensa según cada personaje
      switch (char.name) {
        case "Heroe":
          charElement.src = "./Imagenes/HeroeDef.png";
          break;
        case "Magiño":
          charElement.src = "./Imagenes/MagiñoDef.png";
          break;
        case "Darina":
          charElement.src = "./Imagenes/DarinaDef.png";
          break;
        case "Geralt":
          charElement.src = "./Imagenes/GeraltDef.png";
          break;
      }
      setTimeout(() => charElement.classList.remove("defending"), 500);
    });
  } else {
    // Caso normal: solo el personaje seleccionado se defiende.
    selectedCharacter.defend();
    selectedCharacter.finturno = true;
    const index = Object.keys(characters).indexOf(selectedCharacter.name) + 1;
    const charElement = document.querySelector(`#hero${index} img`);
    charElement.classList.add("defending");

    switch (selectedCharacter.name) {
      case "Heroe":
        charElement.src = "./Imagenes/HeroeDef.png";
        break;
      case "Magiño":
        charElement.src = "./Imagenes/MagiñoDef.png";
        break;
      case "Darina":
        charElement.src = "./Imagenes/DarinaDef.png";
        break;
      case "Geralt":
        charElement.src = "./Imagenes/GeraltDef.png";
        break;
    }
    setTimeout(() => charElement.classList.remove("defending"), 500);
  }

  updateStats();
    }

    

    function useItem() {
  if (selectedCharacter.hp <= 0 || selectedCharacter.finturno) return;

  // Verifica si el personaje está envenenado y elimina el veneno
  if (selectedCharacter.poisoned) {
    selectedCharacter.poisoned = false; // Elimina el estado de veneno
    const index = Object.keys(characters).indexOf(selectedCharacter.name) + 1;
    triggerEffect(`#hero${index}`, 0, "poison"); // Elimina el mensaje de veneno
    console.log(`${selectedCharacter.name} se ha curado del veneno.`);
  }

  if (yaCurao) return; // Evitar más curaciones este turno

  const healSound = document.getElementById("healSound");

  if (selectedCharacter.name === "Heroe") {
    selectedCharacter.finturno = true;
    yaCurao = true; // Evitar más curaciones este turno
    selectHealTarget(); // Si es el héroe, muestra la selección de a quién curar
    selectedCharacter.classList.add("healing-animation");
    return; // Termina aquí para que no se cure a sí mismo
  }

  healSound.currentTime = 0;
  healSound.play();

  if (selectedCharacter.hp <= 0 || selectedCharacter.items <= 0 || selectedCharacter.finturno) return;

  selectedCharacter.useItem(); // Usa el ítem de curación

  const index = Object.keys(characters).indexOf(selectedCharacter.name) + 1;
  const charElement = document.querySelector(`#hero${index} img`);
  triggerEffect(".character", Math.floor(selectedCharacter.maxHp * 0.5), "heal"); // Aplica la curación visualmente

  // Cambiar imagen de curación según el personaje
  switch (selectedCharacter.name) {
    case "Darina":
      charElement.src = "./Imagenes/DarinaCu.png";
      break;
    case "Magiño":
      charElement.src = "./Imagenes/MagiñoCu.png";
      break;
    case "Heroe":
      charElement.src = "./Imagenes/HeroeCu.png";
      break;
    case "Geralt":
      charElement.src = "./Imagenes/GeraltCu.png";
      break;
  }

  charElement.classList.add("healing-animation");
  selectedCharacter.finturno = true;

  setTimeout(() => {
    charElement.classList.remove("healing-animation");
    updateStats(); // Actualiza las estadísticas después de la curación
  }, 5000);
}

    function updatePartyDamageEffect() {
  const party = Object.values(characters);
  let totalCurrentHp = 0;
  let totalMaxHp = 0;
  
  party.forEach(char => {
    totalCurrentHp += char.hp;
    totalMaxHp += char.maxHp;
  });
  
  const percentage = totalCurrentHp / totalMaxHp;
  
  // He puesto 0 pq no me gusta
  let overlayOpacity = Math.min(1 - percentage, 0); 
  overlayOpacity = Math.max(overlayOpacity, 0); // Evita valores negativos

  // Calcula el nivel de escala de grises
  let grayscaleValue = percentage <= 0.1 ? 1 : 1 - ((percentage - 0.1) / 0.9);
  grayscaleValue = Math.max(Math.min(grayscaleValue, 1), 0);

  // Aplicar el filtro al fondo
  const background = document.getElementById("background");
  if (background) {
    background.style.filter = `grayscale(${grayscaleValue})`;
  }

  // Actualizar la opacidad del overlay usando CSS variables
  let overlay = document.getElementById("damage-overlay");
  if (!overlay) {
    overlay = document.createElement("div");
    overlay.id = "damage-overlay";
    document.body.appendChild(overlay);
  }
  
  overlay.style.setProperty("--overlay-opacity", overlayOpacity);
}
    
function openDarinaSkillMenu() {
  // Crear overlay para bloquear la pantalla
  const overlay = document.createElement("div");
  overlay.id = "darina-skill-overlay";
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  overlay.style.zIndex = "2000";

  // Contenedor para los elementos del menú
  const container = document.createElement("div");
  container.style.display = "flex";
  container.style.alignItems = "center";
  
  // Botón de la opción izquierda: aumentar mana a costa de vida
  const leftButton = document.createElement("button");
  leftButton.innerText = "⁂ Aumentar Mana (-30 HP)";
  // Asignar clases para editar en CSS
  leftButton.classList.add("skill-button", "left-btn");
  leftButton.onclick = function() {
    // Verificar que Darina tenga al menos 30 de vida para gastar
    if (selectedCharacter.hp > 30) {
      selectedCharacter.hp -= 30;
      selectedCharacter.mana += 30;
    }
    // Cierra el menú, actualiza estadísticas y marca el turno finalizado
    document.body.removeChild(overlay);
    updateStats();
    selectedCharacter.finturno = true;
  };
  
  // Imagen central de la habilidad
  const centerImage = document.createElement("img");
  centerImage.src = "./Imagenes/DarinaSkill.png";
  centerImage.alt = "Darina Skill";
  // Puedes asignarle también una clase si lo deseas
  centerImage.classList.add("skill-center-image");
  
  // Botón de la opción derecha: atacar con hechizo directamente
  const rightButton = document.createElement("button");
  rightButton.innerText = "Atacar con hechizo ⁂";
  // Asignar clases para editar en CSS
  rightButton.classList.add("skill-button", "right-btn");
  rightButton.onclick = function() {
    if (selectedCharacter.mana >= 10)
    {
    // Realiza el ataque mágico: calcula daño y aplica efecto
    const damage = Math.max(selectedCharacter.attack * 4 - enemy.defense, 1);
    triggerEffect(".enemy-container", damage, "magic");
    selectedCharacter.mana -= 10;
    const magicSound = document.getElementById("magicSound");
    magicSound.currentTime = 0;
    magicSound.play();
    enemy.takeDamage(damage);
    triggerFlash(document.getElementById("enemy"));
    document.body.removeChild(overlay);
    updateStats();
    selectedCharacter.finturno = true;
    }
  };

  // Agregar los elementos al contenedor y éste al overlay
  container.appendChild(leftButton);
  container.appendChild(centerImage);
  container.appendChild(rightButton);
  overlay.appendChild(container);
  document.body.appendChild(overlay);
}

function castMagic() {
  if (selectedCharacter.hp <= 0 || selectedCharacter.finturno) return;
  
  // Si el personaje es Darina, se abre el menú de habilidad especial
  if (selectedCharacter.name === "Darina") {
    openDarinaSkillMenu();
    return;
  }
  
  if(selectedCharacter.mana < 10) return;
  // Para otros personajes (por ejemplo, Magiño), se ejecuta el comportamiento actual
  const originalCharacter = selectedCharacter;
  const index = Object.keys(characters).indexOf(originalCharacter.name) + 1;
  const charElement = document.querySelector(`#hero${index} img`);

  // Cambio de imagen y sonido
  if (originalCharacter.name === "Magiño") {
    charElement.src = `./Imagenes/${originalCharacter.name}Mag.png`;
    const magicSound = document.getElementById("magicSound");
    magicSound.currentTime = 0;
    magicSound.play();
    triggerFlash(document.getElementById("enemy"));
  }

  const damage = Math.max(originalCharacter.attack * 4 - enemy.defense, 1);
  triggerEffect(".enemy-container", damage, "magic");

  setTimeout(() => {
    originalCharacter.useMagic(enemy);
    originalCharacter.finturno = true;
    updateStats();
    setTimeout(() => {
      if (selectedCharacter === originalCharacter) {
        charElement.src = originalCharacter.imgAlive;
      }
    }, 500);
  }, 500);
}

        

        function triggerEffect(containerSelector, amount, type) {
      const effect = document.createElement("div");
      effect.classList.add("damage-number");
      switch (type) {
        case "damage":
          effect.classList.add("damage-negative");
          effect.textContent = "-" + amount;
          break;
        case "heal":
          effect.classList.add("damage-positive");
          effect.textContent = "✙" + amount;
          break;
        case "magic":
          effect.classList.add("damage-magic");
          effect.textContent = "Hechizo! -" + amount+" ۞";
          break;
        case "defend":
          effect.classList.add("damage-defend");
          effect.textContent = "Defendido! " + amount+" ⛨";
          break;
        case "critical":
          effect.classList.add("damage-critical");
          effect.textContent = "CRIT -" + amount+" ❈";
          break;
        case "veneno":
          effect.classList.add("damage-veneno");
          effect.textContent = "☠ ENVENENADO ☠ -10";
          break;
        case "global":
          effect.classList.add("damage-global");
          effect.textContent = "✧ ¡SUFRID! ✧";
          break;
      }

      const container = document.querySelector(containerSelector);
      if (!container) return;
      container.appendChild(effect);
      setTimeout(() => {
        effect.style.opacity = "0";
        effect.style.transform = "translateY(-50px)";
      }, 50);
      setTimeout(() => effect.remove(), 1000);
    }
    function poisonDamage() {
  Object.values(characters).forEach(char => {
    if (char.poisoned && char.hp > 0) {
      console.log(`${char.name} ha recibido 10 puntos de daño por veneno.`);
      char.takeDamage(10);
      triggerEffect(`#hero${Object.keys(characters).indexOf(char.name) + 1}`, 10, "veneno");
    }
  });
}

function triggerShake(element) {
  element.classList.add('shake');
  // Quita la clase tras la duración de la animación para poder volver a activarla en el futuro.
  setTimeout(() => {
    element.classList.remove('shake');
  }, 500);
}

function triggerFlash(element) {
  // Aplica la animación de destello al elemento (enemigo)
  element.classList.add('flash');
  
  // Oscurece el fondo aplicando un filtro con transición
  const background = document.getElementById("background");
  if (background) {
    background.style.transition = 'filter 1s ease-out';
    background.style.filter = 'brightness(0.6)';
  }

  // Remueve ambas clases tras la duración de la animación
  setTimeout(() => {
    element.classList.remove('flash');
    if (background) {
      background.style.filter = 'brightness(1)'; // Vuelve a la normalidad suavemente
    }
  }, 500);
}


function endTurn() {
  let aliveCharacters = Object.values(characters).filter(char => char.hp > 0);  // Verifica los personajes vivos

  // Si no hay personajes vivos, termina el juego y redirige a GameOver.html
  if (aliveCharacters.length === 0) {
    window.location.href = "GameOver.html";
    return;
  }

  // Si todos los personajes están envenenados, el enemigo juega de nuevo automáticamente
  if (aliveCharacters.every(char => char.poisoned)) {
    setTimeout(() => {
      Object.values(characters).forEach(char => char.poisoned = false); // Elimina el veneno después del turno perdido
      endTurn(); // Enemigo vuelve a jugar
    }, 1000);
    return;
  }

  const enemyAction = Math.random();

  if (enemyAction < 0.3) {  
    // 30% de probabilidad de envenenar a un héroe
    const randomTarget = aliveCharacters[Math.floor(Math.random() * aliveCharacters.length)];
    if (!randomTarget.poisoned) {
      randomTarget.poisoned = true; // El héroe seleccionado es envenenado
      const targetIndex = Object.keys(characters).indexOf(randomTarget.name) + 1;
      triggerEffect(`#hero${targetIndex}`, 0, "poison");
      console.log(`${randomTarget.name} ha sido envenenado y perderá 10 puntos de vida por turno.`);
      const veneno = document.getElementById("veneno");
          veneno.currentTime = 0;
          veneno.play();
    }

  } else if (enemyAction < 0.5) {  
    // 20% de probabilidad de ATAQUE GLOBAL
    let globalDamage = Math.floor(Math.random() * (50 - 25 + 1)) + 25;
    aliveCharacters.forEach(char => {
      const targetIndex = Object.keys(characters).indexOf(char.name) + 1;
      triggerEffect(`#hero${targetIndex}`, globalDamage, "global");
      const global = document.getElementById("global");
          global.currentTime = 0;
          global.play();
    });

    setTimeout(() => {
      aliveCharacters.forEach(char => char.takeDamage(globalDamage));
    }, 200);

  } else {  
    // 50% de probabilidad de ataque normal
    const randomTarget = aliveCharacters[Math.floor(Math.random() * aliveCharacters.length)];
    let damage = Math.floor(Math.random() * (60 - 30 + 1)) + 30;
    const targetIndex = Object.keys(characters).indexOf(randomTarget.name) + 1;

    if (randomTarget.defending) {
      triggerEffect(`#hero${targetIndex}`, damage, "defend");
      damage = Math.floor(damage / 3);
    } else {
      triggerEffect(`#hero${targetIndex}`, damage, "damage");
    }

    setTimeout(() => {
      randomTarget.takeDamage(damage);
    }, 200);
  }

  // Animación del ataque enemigo
  const enemyImg = document.querySelector(".enemy-container img");
  enemyIsAttacking = true;
  enemyImg.src = "./Imagenes/Boss2Ataque.png";
  enemyImg.classList.add("enemy-attack");

  const EnemyAttack = document.getElementById("EnemyAttack");
  EnemyAttack.currentTime = 0;
  EnemyAttack.play();
  yaCurao = false;

  setTimeout(() => {
    enemyImg.classList.remove("enemy-attack");
    enemyImg.src = enemy.imgAlive;
    enemyIsAttacking = false;
  }, 500);

  // Llama a la función de veneno después de las acciones del turno
  poisonDamage();

  // Reinicia estados de turno y defensa
  Object.values(characters).forEach(char => {
    char.finturno = false;
    char.defending = false;
  });

  document.querySelectorAll('.character img').forEach(img => {
    img.style.border = "3px solid transparent";
  });

  updateStats();
}
  </script>
</body>
</html>